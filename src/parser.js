// A parser for JSON.

import { SyntaxError } from './error.js';
import { getTokenTypeName, Lexer, TOKEN_TYPE } from './lexer.js';

function CHECK(condition) {
  if (!condition) throw new Error('Assertion failed');
}

const PIECE = {
  PROPERTY_NAME: 1,
  COLON: 2,
  VALUE: 3,
  COMA: 4
};

export class Parser {

  #lexer = new Lexer();
  #events;
  #options;
  #hasPlaceholder;

  // Options:
  // * include_incomplete_strings (bool|string): if not false, partially parsed strings are set
  //   after parsing each chunk. This option can be set to a string (e.g. "..."), in which case
  //   this string is appended at the end of partially parsed strings.
  // * track_events: if true, events are tracked when values are set. They are returned by takeEvents().
  constructor(opt_options) {
    this.#options = opt_options || {};
    this.reset();
  }

  // --------------------------------------------------------------------------------
  // The interface for the parser.

  // Append some text to the input string to be parsed.
  push(text) {
    const length = text.length;
    for (let index = 0; index < length; ++index) {
      this.#lexer.lex(text[index]);
      this.#parse();
    }
    this.#lexer.flush();
    this.#parse();
    this.#includeIncompleteString();
  }

  // End the parsing of the input string.
  close() {
    this.#lexer.close();
    this.#parse();
    this.#throwSyntaxErrorIfStackIsNotEmpty();
  }

  // Reset the parser to its initial state so that a new input string can be parsed.
  reset() {
    this.#lexer.reset();
    this.#events = [];
    this.#hasPlaceholder = false;
    this.#stack = [{isArray: true, value: [], key: 0, expectedPiece: PIECE.VALUE, isEmpty: true}];
    this.#stringBuffer = null;
  }

  // Set a placeholder for the root value. Must be called before parsing starts.
  setPlaceholder(placeholder) {
    if (this.#stack.length !== 1 || this.#stack[0].value.length !== 0) throw 'Cannot set placeholder after starting parsing.';
    this.#stack[0].value[0] = placeholder;
    this.#hasPlaceholder = true;
  }

  // Get the root value which has been parsed so far.
  getValue() { return this.#stack[0].value[0]; }

  // Get the events generated by the parser since the last call to this method.
  takeEvents() {
    if (!this.#options.track_events) throw 'Events are not tracked.';
    const events = this.#events;
    this.#events = [];
    return events;
  }

  // --------------------------------------------------------------------------------
  // The implementation for the parser.

  // A stack of contexts designating the current node of the root value being set.
  // Possible stack values:
  // * {isArray: true, value: [...], key: <number>, expectedPiece: <PIECE>, isEmpty: <boolean> }
  //   key is the index of the value array to be set. if key == value.length, a value is expected,
  //   if key < value.length, a coma is expected.
  // * {isArray: false, value: {...}, key: <string>, expectedPiece: <PIECE>, isEmpty: <boolean>, propertyNames: <Set<string>>}
  #stack;
  #stringBuffer;

  #throwSyntaxError(message) { this.#lexer.throwSyntaxError(message); }
  #throwUnexpectedTokenError(tokenType) { this.#throwSyntaxError(`Unexpected token: "${getTokenTypeName(tokenType)}"`); }

  #setIncompleteValue(context, value) {
    if (context.expectedPiece !== PIECE.VALUE) this.#throwSyntaxError(`Unexpected value`);
    context.value[context.key] = value;
    context.isEmpty = false;
  }

  #pushEvent(type) {
    if (this.#options.track_events) {
      this.#events.push({
        type,
        path: this.#stack.slice(1).map(context => context.key)
      });
    }
  }

  #setValue(value) {
    let context = this.#stack.at(-1);
    this.#setIncompleteValue(context, value);
    context.expectedPiece = PIECE.COMA;
    this.#pushEvent(typeof value === 'object' ? 'begin' : 'set');
  }

  #getValue(context) {
    return context.value[context.key];
  }

  #nextArrayItemOrObjectProperty(context) {
    if (context.isArray) {
      ++context.key;
      context.expectedPiece = PIECE.VALUE;
    } else {
      if (this.#hasPlaceholder) context.propertyNames.add(context.key);
      context.expectedPiece = PIECE.PROPERTY_NAME;
    }
  }

  #closeArrayOrObject(context) {
    if (!context.isEmpty) this.#nextArrayItemOrObjectProperty(context);
    if (this.#hasPlaceholder) {
      // Remove items/properties that were in the placeholder but not in the parsed value.
      if (context.isArray) {
        context.value.length = context.key;
      } else {
        for (const propertyName in context.value) {
          if (!context.propertyNames.has(propertyName)) delete context.value[propertyName];
        }
      }
    }
    this.#stack.pop();
    this.#pushEvent('end');
  }

  // Process all tokens which are in the lexer buffer.
  #parse() {
    for (let index = 0; index < this.#lexer.numberOfTokens; ++index) {
      const context = this.#stack.at(-1);
      const tokenType = this.#lexer.tokenTypes[index];
      if (this.#stringBuffer === null) {
        switch (tokenType) {
          case TOKEN_TYPE.LITERAL:
            this.#setValue(this.#lexer.tokenValues[index]);
            break;
          case TOKEN_TYPE.START_OBJECT:
            let newObject = this.#getValue(context) || {};
            this.#setValue(newObject);
            this.#stack.push(
              {isArray: false, value: newObject, expectedPiece: PIECE.PROPERTY_NAME, propertyNames: this.#hasPlaceholder ? new Set() : undefined, isEmpty: true});
            break;
          case TOKEN_TYPE.END_OBJECT:
            if (context.isArray || context.expectedPiece !== (context.isEmpty ? PIECE.PROPERTY_NAME : PIECE.COMA)) {
              this.#throwUnexpectedTokenError(tokenType);
            }
            this.#closeArrayOrObject(context);
            break;
          case TOKEN_TYPE.START_ARRAY:
            let newArray = this.#getValue(context) || [];
            this.#setValue(newArray);
            this.#stack.push({isArray: true, value: newArray, key: 0, expectedPiece: PIECE.VALUE, isEmpty: true});
            break;
          case TOKEN_TYPE.END_ARRAY:
            if (!context.isArray || (!context.isEmpty && context.expectedPiece === PIECE.VALUE)) {
              this.#throwUnexpectedTokenError(tokenType);
            }
            this.#closeArrayOrObject(context);
            break;
          case TOKEN_TYPE.COLON:
            if (context.isArray) {
              this.#throwUnexpectedTokenError(tokenType);
            } else {
              if (context.expectedPiece !== PIECE.COLON) {
                this.#throwUnexpectedTokenError(tokenType);
              }
              context.expectedPiece = PIECE.VALUE;
            }
            break;
          case TOKEN_TYPE.COMA:
            if (context.expectedPiece !== PIECE.COMA) this.#throwUnexpectedTokenError(tokenType);
            this.#nextArrayItemOrObjectProperty(context);
            break;
          case TOKEN_TYPE.START_STRING:
            if (!(context.expectedPiece === PIECE.VALUE || context.expectedPiece === PIECE.PROPERTY_NAME)) {
              this.#throwUnexpectedTokenError(tokenType);
            }
            this.#stringBuffer = [];
            break;
          // By construction, the lexer cannot emit STRING_CHUNK or END_STRING here.
        }
      } else {
        this.#stringBuffer.push(this.#lexer.tokenValues[index]);
        if (tokenType === TOKEN_TYPE.END_STRING) {
          let value = this.#stringBuffer.join('');
          if (context.expectedPiece === PIECE.PROPERTY_NAME) {
            context.expectedPiece = PIECE.COLON;
            context.key = value;
          } else {
            this.#setValue(value);
          }
          this.#stringBuffer = null;
        }
      }
    }
  }

  // Include the incomplete string in the root value. To be called after parsing a chunk of the input string.
  #includeIncompleteString() {
    if (this.#options.include_incomplete_strings && this.#stringBuffer !== null) {
      const context = this.#stack.at(-1);
      if (context.expectedPiece === PIECE.VALUE) {
        let value = this.#stringBuffer.join('');
        this.#stringBuffer = [value];
        this.#setIncompleteValue(context, value + (typeof this.#options.include_incomplete_strings === 'string' ? this.#options.include_incomplete_strings : ''));
      }
    }
  }

  // Throw an error if the stack is not empty.
  #throwSyntaxErrorIfStackIsNotEmpty() {
    if (this.#stack.length === 1) return;
    let context = this.#stack.at(-1);
    this.#throwSyntaxError(`Unterminated ${CONTEXT_TYPE_NAME[context.type]}`);
  }
}

// Iterator-based interface for the parser.
export function* parse(stream, opt_options) {
  let parser = new Parser(opt_options);
  const trackEvents = opt_options?.track_events;
  for (const chunk of stream) {
    parser.push(chunk);
    yield {root: parser.getValue(), events: trackEvents && parser.takeEvents(), done: false};
  }
  parser.close();
  yield {root: parser.getValue(), events: trackEvents && parser.takeEvents(), done: true};
}
