// A parser for JSON.

import { SyntaxError } from './error.js';
import { getTokenTypeName, Lexer, TOKEN_TYPE } from './lexer.js';

function CHECK(condition) {
  if (!condition) throw new Error('Assertion failed');
}

const CONTEXT_TYPE = {
  OBJECT: 1,
  ARRAY: 2,
  STRING : 3
};

const CONTEXT_TYPE_NAME = [
  null,  // index 0 is unused
  'object',  // 1: CONTEXT_TYPE.OBJECT
  'array',  // 2: CONTEXT_TYPE.ARRAY
  'string'  // 3: CONTEXT_TYPE.STRING
];

const PIECE = {
  PROPERTY_NAME: 1,
  COLON: 2,
  VALUE: 3,
  COMA: 4
};

export class Parser {

  #lexer = new Lexer();
  #events;
  #options;
  #hasPlaceholder;

  // Options:
  // * include_incomplete_strings (bool|string): if not false, partially parsed strings are set
  //   after parsing each chunk. This option can be set to a string (e.g. "..."), in which case
  //   this string is appended at the end of partially parsed strings.
  // * track_events: if true, events are tracked when values are set. They are returned by takeEvents().
  constructor(opt_options) {
    this.#options = opt_options || {};
    this.reset();
  }

  // --------------------------------------------------------------------------------
  // The interface for the parser.

  // Append some text to the input string to be parsed.
  push(text) {
    const length = text.length;
    for (let index = 0; index < length; ++index) {
      this.#lexer.lex(text[index]);
      this.#parse();
    }
    this.#lexer.flush();
    this.#parse();
    this.#includeIncompleteString();
  }

  // End the parsing of the input string.
  close() {
    this.#lexer.close();
    this.#parse();
    this.#throwSyntaxErrorIfStackIsNotEmpty();
  }

  // Reset the parser to its initial state so that a new input string can be parsed.
  reset() {
    this.#lexer.reset();
    this.#events = [];
    this.#hasPlaceholder = false;
    this.#stack = [{type: CONTEXT_TYPE.ARRAY, value: [], key: 0, expectedPiece: PIECE.VALUE, isEmpty: true}];
  }

  // Set a placeholder for the root value. Must be called before parsing starts.
  setPlaceholder(placeholder) {
    if (this.#stack.length !== 1 || this.#stack[0].value.length !== 0) throw 'Cannot set placeholder after starting parsing.';
    this.#stack[0].value[0] = placeholder;
    this.#hasPlaceholder = true;
  }

  // Get the root value which has been parsed so far.
  getValue() { return this.#stack[0].value[0]; }

  // Get the events generated by the parser since the last call to this method.
  takeEvents() {
    if (!this.#options.track_events) throw 'Events are not tracked.';
    const events = this.#events;
    this.#events = [];
    return events;
  }

  // --------------------------------------------------------------------------------
  // The implementation for the parser.

  // A stack of contexts designating the current node of the root value being set.
  // Possible stack values:
  // * {type: CONTEXT_TYPE.ARRAY, value: [...], key: <number>, expectedPiece: <PIECE>, isEmpty: <boolean> }
  //   key is the index of the value array to be set. if key == value.length, a value is expected,
  //   if key < value.length, a coma is expected.
  // * {type: CONTEXT_TYPE.OBJECT, value: {...}, key: <string>, expectedPiece: <PIECE>, isEmpty: <boolean>, propertyNames: <Set<string>>}
  // * {type: STRING, value: "..."} 
  #stack;

  #throwSyntaxError(message) { this.#lexer.throwSyntaxError(message); }
  #throwUnexpectedTokenError(tokenType) { this.#throwSyntaxError(`Unexpected token: "${getTokenTypeName(tokenType)}"`); }

  #expectObjectPropertyName(context) {
    return context.type === CONTEXT_TYPE.OBJECT && context.expectedPiece === PIECE.PROPERTY_NAME;
  }

  #canSetValue(context) {
    return context.type !== CONTEXT_TYPE.STRING && context.expectedPiece === PIECE.VALUE;
  }

  #setIncompleteValue(context, value) {
    if (!this.#canSetValue(context)) this.#throwSyntaxError(`Unexpected value`);
    context.value[context.key] = value;
    context.isEmpty = false;
  }

  #pushEvent(type) {
    if (this.#options.track_events) {
      this.#events.push({
        type,
        path: this.#stack.slice(1).map(context => context.key)
      });
    }
  }

  #setValue(value) {
    let context = this.#stack.at(-1);
    this.#setIncompleteValue(context, value);
    context.expectedPiece = PIECE.COMA;
    this.#pushEvent(typeof value === 'object' ? 'begin' : 'set');
  }

  #getValue(context) {
    CHECK(context.type !== CONTEXT_TYPE.STRING);
    return context.value[context.key];
  }

  #nextArrayItemOrObjectProperty(context) {
    switch (context.type) {
      case CONTEXT_TYPE.ARRAY:
        ++context.key;
        context.expectedPiece = PIECE.VALUE;
        break;
      case CONTEXT_TYPE.OBJECT:
        if (this.#hasPlaceholder) context.propertyNames.add(context.key);
        context.expectedPiece = PIECE.PROPERTY_NAME;
        break;
    }
  }

  #closeArrayOrObject(context) {
    if (!context.isEmpty) this.#nextArrayItemOrObjectProperty(context);
    if (this.#hasPlaceholder) {
      // Remove items/properties that were in the placeholder but not in the parsed value.
      switch (context.type) {
        case CONTEXT_TYPE.ARRAY:
          context.value.length = context.key;
          break;
        case CONTEXT_TYPE.OBJECT:
          for (const propertyName in context.value) {
            if (!context.propertyNames.has(propertyName)) delete context.value[propertyName];
          }
          break;
      }
    }
    this.#stack.pop();
    this.#pushEvent('end');
  }

  // Process all tokens which are in the lexer buffer.
  #parse() {
    for (let index = 0; index < this.#lexer.numberOfTokens; ++index) {
      const context = this.#stack.at(-1);
      const tokenType = this.#lexer.tokenTypes[index];
      switch (tokenType) {
        case TOKEN_TYPE.LITERAL:
          this.#setValue(this.#lexer.tokenValues[index]);
          break;
        case TOKEN_TYPE.START_OBJECT:
          let newObject = this.#getValue(context) || {};
          this.#setValue(newObject);
          this.#stack.push(
            {type: CONTEXT_TYPE.OBJECT, value: newObject, expectedPiece: PIECE.PROPERTY_NAME, propertyNames: this.#hasPlaceholder ? new Set() : undefined, isEmpty: true});
          break;
        case TOKEN_TYPE.END_OBJECT:
          if (context.type !== CONTEXT_TYPE.OBJECT || context.expectedPiece !== (context.isEmpty ? PIECE.PROPERTY_NAME : PIECE.COMA)) {
            this.#throwUnexpectedTokenError(tokenType);
          }
          this.#closeArrayOrObject(context);
          break;
        case TOKEN_TYPE.START_ARRAY:
          let newArray = this.#getValue(context) || [];
          this.#setValue(newArray);
          this.#stack.push({type: CONTEXT_TYPE.ARRAY, value: newArray, key: 0, expectedPiece: PIECE.VALUE, isEmpty: true});
          break;
        case TOKEN_TYPE.END_ARRAY:
          if (context.type !== CONTEXT_TYPE.ARRAY || (!context.isEmpty && context.expectedPiece === PIECE.VALUE)) {
            this.#throwUnexpectedTokenError(tokenType);
          }
          this.#closeArrayOrObject(context);
          break;
        case TOKEN_TYPE.COLON:
          switch (context.type) {
            case CONTEXT_TYPE.ARRAY: this.#throwUnexpectedTokenError(tokenType);
            case CONTEXT_TYPE.OBJECT:
              if (context.type !== CONTEXT_TYPE.OBJECT || context.expectedPiece !== PIECE.COLON) {
                this.#throwUnexpectedTokenError(tokenType);
              }
              context.expectedPiece = PIECE.VALUE;
              break;
            case CONTEXT_TYPE.STRING: CHECK(false);
          }
          break;
        case TOKEN_TYPE.COMA:
          CHECK(context.type !== CONTEXT_TYPE.STRING);
          if (context.expectedPiece !== PIECE.COMA) this.#throwUnexpectedTokenError(tokenType);
          this.#nextArrayItemOrObjectProperty(context);
          break;
        case TOKEN_TYPE.START_STRING:
          if (!(this.#canSetValue(context) || this.#expectObjectPropertyName(context))) {
            this.#throwUnexpectedTokenError(tokenType);
          }
          this.#stack.push({type: CONTEXT_TYPE.STRING, value: ''});
          break;
        case TOKEN_TYPE.STRING_CHUNK:
          CHECK(context.type === CONTEXT_TYPE.STRING);
          context.value += this.#lexer.tokenValues[index];
          break;
        case TOKEN_TYPE.END_STRING:
          CHECK(context.type === CONTEXT_TYPE.STRING);
          context.value += this.#lexer.tokenValues[index];
          this.#stack.pop();
          const newContext = this.#stack.at(-1);
          if (this.#expectObjectPropertyName(newContext)) {
            newContext.expectedPiece = PIECE.COLON;
            newContext.key = context.value;
          } else {
            this.#setValue(context.value);
          }
          break;      
      }
    }
  }

  // Include the incomplete string in the root value. To be called after parsing a chunk of the input string.
  #includeIncompleteString() {
    if (this.#options.include_incomplete_strings && this.#stack.length > 1) {
      const context1 = this.#stack.at(-1), context2 = this.#stack.at(-2);
      if (context1.type == CONTEXT_TYPE.STRING && !this.#expectObjectPropertyName(context2)) {
        this.#setIncompleteValue(context2, context1.value + (typeof this.#options.include_incomplete_strings === 'string' ? this.#options.include_incomplete_strings : ''));
      }
    }
  }

  // Throw an error if the stack is not empty.
  #throwSyntaxErrorIfStackIsNotEmpty() {
    if (this.#stack.length === 1) return;
    let context = this.#stack.at(-1);
    this.#throwSyntaxError(`Unterminated ${CONTEXT_TYPE_NAME[context.type]}`);
  }
}

// Iterator-based interface for the parser.
export function* parse(stream, opt_options) {
  let parser = new Parser(opt_options);
  const trackEvents = opt_options?.track_events;
  for (const chunk of stream) {
    parser.push(chunk);
    yield {root: parser.getValue(), events: trackEvents && parser.takeEvents(), done: false};
  }
  parser.close();
  yield {root: parser.getValue(), events: trackEvents && parser.takeEvents(), done: true};
}
